<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.ticks {
  font: 10px sans-serif;
}

.track,
.track-inset,
.track-overlay {
  stroke-linecap: round;
}

.track {
  stroke: #000;
  stroke-opacity: 0.3;
  stroke-width: 10px;
}

.track-inset {
  stroke: #ddd;
  stroke-width: 8px;
}

.track-overlay {
  pointer-events: stroke;
  stroke-width: 50px;
  stroke: transparent;
  cursor: crosshair;
}

</style>
<svg width="960" height="600"></svg>
<div id="slider"></div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var svg = d3.select("svg"),
    margin = {right: 50, left: 50}, 
    width = +svg.attr("width"),
    height = +svg.attr("height");

var x = d3.scaleLinear()
    .domain([0, 180])
    .range([0, width])
    .clamp(true);

var slider = svg.append("g")
    .attr("class", "slider")
    .attr("transform", "translate(" + (margin.left -5) + "," + (height -20) + ")");

slider.append("line")
    .attr("class", "track")
    .attr("x1", x.range()[0])
    .attr("x2", x.range()[1])
  .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-inset")
  .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-overlay")
    .call(d3.drag()
        .on("start.interrupt", function() { slider.interrupt(); })
        .on("start drag", function() { hue(x.invert(d3.event.x)); }));

slider.insert("g", ".track-overlay")
    .attr("class", "ticks")
    .attr("transform", "translate(0," + 18 + ")")
  .selectAll("text")
  .data(x.ticks(10))
  .enter().append("text")
    .attr("x", x)
    .attr("text-anchor", "middle")
    .text(function(d) { return d; });

var handle = slider.insert("circle", ".track-overlay")
    .attr("class", "handle")
    .attr("r", 9);

slider.transition() // Gratuitous intro!
    .duration(750)
    .tween("hue", function() {
      var i = d3.interpolate(0, 70);
      return function(t) { hue(i(t)); };
    });
    
//var color = d3.scaleOrdinal(d3.schemeCategory20);


var color = d3.scaleQuantize()
    .domain([0, 2950])
    .range([d3.schemeCategory20]);

let uniqObj = {};

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2));

d3.csv("comm-data-Fri.csv", function(data) {

  let allComms = [];
  let allToComms = [];
  let links = {};
  let unique = [];
  let listOfLinks = [];

  let num = 2000;


  data.forEach(function(d) {
    allComms.push(parseInt(d.from));
    allToComms.push(parseInt(d.to));
  })

  for(var i = 0; i < num; i++){
    if(unique.indexOf(allComms[i]) === -1){
      unique.push(allComms[i]);
    }
    if(unique.indexOf(allToComms[i]) === -1) {
      unique.push(allToComms[i]);
    }
  }

  // Initializing a JSON-formatted object with an array of all communcation sources to target.
  for(var k = 0; k < num; k++){
    let tinyObj2 = {};
    tinyObj2.source = allComms[k];
    tinyObj2.target = allToComms[k];
    tinyObj2.value = 1;
    listOfLinks.push(tinyObj2);
  }

  let listOfGroups = [];
  let j = 0;
  unique.forEach( function(element) {
    let tinyObj = {};
    tinyObj.id = element;
    tinyObj.group = j;
    j++;
    listOfGroups.push(tinyObj);
  })
  listOfGroups.push({"id": "0", "group": 2950});
  console.log(listOfGroups.length);
  uniqObj = listOfGroups;
  
  var link = svg.append("g")
      .attr("class", "links")
    .selectAll("line")
    .data(listOfLinks)
    .enter().append("line")
      .attr("stroke-width", function(d) { return Math.sqrt(d.value);});

  console.log("Done with the links!");
  var node = svg.append("g")
    .attr("class", "nodes")
    .selectAll("circle")
    .data(uniqObj)
    .enter().append("circle")
      .attr("r", 5)
      .attr("fill", function(d) {return color(d.group);})
      //.attr("fill", "red")
      .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended)); 

  console.log("Done with the nodes!");
  node.append("title")
      .text(function(d) { return d.id; });

  simulation
      .nodes(uniqObj)
      .on("tick", ticked);

  simulation.force("link")
      .links(listOfLinks);

  console.log("Done with the shit!");
  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  }
});


svg = d3.select("svg")
 .append("svg")
 .attr("width", "100%")
 .attr("height", "100%")
 .call(d3.zoom().on("zoom", function () {
    svg.attr("transform", d3.event.transform)
 }))
 .append("g")


function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

function hue(h) {
  handle.attr("cx", x(h));
  svg.style("background-color", d3.hsl(h, 0.8, 0.8));
}

</script>